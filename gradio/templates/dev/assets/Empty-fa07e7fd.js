import{SvelteComponentDev as y,init as z,safe_not_equal as j,dispatch_dev as b,create_slot as k,validate_slots as P,element as f,attr_dev as h,add_location as p,toggle_class as c,insert_dev as C,append_dev as R,update_slot_base as B,get_all_dirty_from_scope as S,get_slot_changes as O,transition_in as q,transition_out as D,detach_dev as N,binding_callbacks as U}from"../../../node/dev/svelte-internal.js";import"./index-168e7816.js";import"./Button-e33227ec.js";const g="Users/peterallen/Projects/gradio/js/atoms/src/Empty.svelte";function _(o){let e,s,i;const u=o[5].default,l=k(u,o,o[4],null),d={c:function(){e=f("div"),s=f("div"),l&&l.c(),h(s,"class","icon svelte-1hk1nn0"),p(s,g,26,1,584),h(e,"class","empty svelte-1hk1nn0"),c(e,"small",o[0]==="small"),c(e,"large",o[0]==="large"),c(e,"unpadded_box",o[1]),c(e,"small_parent",o[3]),p(e,g,18,0,425)},l:function(n){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(n,a){C(n,e,a),R(e,s),l&&l.m(s,null),o[6](e),i=!0},p:function(n,[a]){l&&l.p&&(!i||a&16)&&B(l,u,n,n[4],i?O(u,n[4],a,null):S(n[4]),null),(!i||a&1)&&c(e,"small",n[0]==="small"),(!i||a&1)&&c(e,"large",n[0]==="large"),(!i||a&2)&&c(e,"unpadded_box",n[1]),(!i||a&8)&&c(e,"small_parent",n[3])},i:function(n){i||(q(l,n),i=!0)},o:function(n){D(l,n),i=!1},d:function(n){n&&N(e),l&&l.d(n),o[6](null)}};return b("SvelteRegisterBlock",{block:d,id:_.name,type:"component",source:"",ctx:o}),d}function A(o,e,s){let i,{$$slots:u={},$$scope:l}=e;P("Empty",u,["default"]);let{size:d="small"}=e,{unpadded_box:r=!1}=e,n;function a(t){if(!t)return!1;const{height:m}=t.getBoundingClientRect(),{height:v}=t.parentElement?.getBoundingClientRect()||{height:m};return m>v+2}const w=["size","unpadded_box"];Object.keys(e).forEach(t=>{!~w.indexOf(t)&&t.slice(0,2)!=="$$"&&t!=="slot"&&console.warn(`<Empty> was created with unknown prop '${t}'`)});function E(t){U[t?"unshift":"push"](()=>{n=t,s(2,n)})}return o.$$set=t=>{"size"in t&&s(0,d=t.size),"unpadded_box"in t&&s(1,r=t.unpadded_box),"$$scope"in t&&s(4,l=t.$$scope)},o.$capture_state=()=>({size:d,unpadded_box:r,el:n,compare_el_to_parent:a,parent_height:i}),o.$inject_state=t=>{"size"in t&&s(0,d=t.size),"unpadded_box"in t&&s(1,r=t.unpadded_box),"el"in t&&s(2,n=t.el),"parent_height"in t&&s(3,i=t.parent_height)},e&&"$$inject"in e&&o.$inject_state(e.$$inject),o.$$.update=()=>{o.$$.dirty&4&&s(3,i=a(n))},[d,r,n,i,l,u,E]}class I extends y{constructor(e){super(e),z(this,e,A,_,j,{size:0,unpadded_box:1}),b("SvelteRegisterComponent",{component:this,tagName:"Empty",options:e,id:_.name})}get size(){throw new Error("<Empty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set size(e){throw new Error("<Empty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get unpadded_box(){throw new Error("<Empty>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set unpadded_box(e){throw new Error("<Empty>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}export{I as E};
//# sourceMappingURL=Empty-fa07e7fd.js.map
