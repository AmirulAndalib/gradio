import{SvelteComponentDev as Q,init as V,safe_not_equal as W,dispatch_dev as g,ensure_array_like_dev as M,validate_each_keys as U,create_slot as X,validate_slots as Y,validate_store as z,component_subscribe as F,createEventDispatcher as P,setContext as G,tick as le,element as j,space as I,attr_dev as p,add_location as R,toggle_class as H,insert_dev as T,append_dev as y,update_keyed_each as ae,destroy_block as re,update_slot_base as Z,get_all_dirty_from_scope as x,get_slot_changes as $,transition_in as q,transition_out as A,detach_dev as k,set_store_value as J,empty as K,text as ee,listen_dev as de,set_data_dev as te,binding_callbacks as ue,bind as _e,create_component as me,mount_component as fe,add_flush_callback as be,destroy_component as he}from"../../../node/dev/svelte-internal.js";import{w as C}from"./index-09ad131b.js";const B="Users/peterallen/Projects/gradio/js/tabs/static/Tabs.svelte";function E(t,e,s){const o=t.slice();return o[14]=e[s],o[16]=s,o}function se(t){let e,s=t[14].name+"",o,f,m,c;function l(){return t[12](t[14],t[16])}const i={c:function(){e=j("button"),o=ee(s),f=I(),p(e,"class","svelte-6uwdd7"),R(e,B,64,4,1393)},m:function(d,_){T(d,e,_),y(e,o),y(e,f),m||(c=de(e,"click",l,!1,!1,!1,!1),m=!0)},p:function(d,_){t=d,_&8&&s!==(s=t[14].name+"")&&te(o,s)},d:function(d){d&&k(e),m=!1,c()}};return g("SvelteRegisterBlock",{block:i,id:se.name,type:"else",source:"(46:3) {:else}",ctx:t}),i}function ne(t){let e,s=t[14].name+"",o,f;const m={c:function(){e=j("button"),o=ee(s),f=I(),p(e,"class","selected svelte-6uwdd7"),R(e,B,60,4,1324)},m:function(l,i){T(l,e,i),y(e,o),y(e,f)},p:function(l,i){i&8&&s!==(s=l[14].name+"")&&te(o,s)},d:function(l){l&&k(e)}};return g("SvelteRegisterBlock",{block:m,id:ne.name,type:"if",source:"(42:3) {#if t.id === $selected_tab}",ctx:t}),m}function O(t,e){let s,o;function f(i,r){return i[14].id===i[4]?ne:se}let m=f(e),c=m(e);const l={key:t,first:null,c:function(){s=K(),c.c(),o=K(),this.first=s},m:function(r,d){T(r,s,d),c.m(r,d),T(r,o,d)},p:function(r,d){e=r,m===(m=f(e))&&c?c.p(e,d):(c.d(1),c=m(e),c&&(c.c(),c.m(o.parentNode,o)))},d:function(r){r&&(k(s),k(o)),c.d(r)}};return g("SvelteRegisterBlock",{block:l,id:O.name,type:"each",source:"(41:2) {#each tabs as t, i (t.id)}",ctx:e}),l}function N(t){let e,s,o=[],f=new Map,m,c,l,i=M(t[3]);const r=b=>b[14].id;U(t,i,E,r);for(let b=0;b<i.length;b+=1){let u=E(t,i,b),n=r(u);f.set(n,o[b]=O(n,u))}const d=t[11].default,_=X(d,t,t[10],null),h={c:function(){e=j("div"),s=j("div");for(let u=0;u<o.length;u+=1)o[u].c();m=I(),_&&_.c(),p(s,"class","tab-nav scroll-hide svelte-6uwdd7"),R(s,B,57,1,1224),p(e,"class",c="tabs "+t[2].join(" ")+" svelte-6uwdd7"),p(e,"id",t[1]),H(e,"hide",!t[0]),R(e,B,56,0,1144)},l:function(u){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(u,n){T(u,e,n),y(e,s);for(let v=0;v<o.length;v+=1)o[v]&&o[v].m(s,null);y(e,m),_&&_.m(e,null),l=!0},p:function(u,[n]){n&408&&(i=M(u[3]),U(u,i,E,r),o=ae(o,n,r,1,u,i,f,s,re,O,null,E)),_&&_.p&&(!l||n&1024)&&Z(_,d,u,u[10],l?$(d,u[10],n,null):x(u[10]),null),(!l||n&4&&c!==(c="tabs "+u[2].join(" ")+" svelte-6uwdd7"))&&p(e,"class",c),(!l||n&2)&&p(e,"id",u[1]),(!l||n&5)&&H(e,"hide",!u[0])},i:function(u){l||(q(_,u),l=!0)},o:function(u){A(_,u),l=!1},d:function(u){u&&k(e);for(let n=0;n<o.length;n+=1)o[n].d();_&&_.d(u)}};return g("SvelteRegisterBlock",{block:h,id:N.name,type:"component",source:"",ctx:t}),h}const L={};function we(t,e,s){let o,f,{$$slots:m={},$$scope:c}=e;Y("Tabs",m,["default"]);let{visible:l=!0}=e,{elem_id:i="id"}=e,{elem_classes:r=[]}=e,{selected:d}=e,_=[];const h=C(!1);z(h,"selected_tab"),F(t,h,a=>s(4,f=a));const b=C(0);z(b,"selected_tab_index"),F(t,b,a=>s(13,o=a));const u=P();G(L,{register_tab:a=>(_.push({name:a.name,id:a.id}),h.update(w=>w??a.id),s(3,_),_.length-1),unregister_tab:a=>{const w=_.findIndex(S=>S.id===a.id);_.splice(w,1),h.update(S=>S===a.id?_[w]?.id||_[_.length-1]?.id:S)},selected_tab:h,selected_tab_index:b});function n(a){s(9,d=a),J(h,f=a,f),J(b,o=_.findIndex(w=>w.id===a),o),u("change")}t.$$.on_mount.push(function(){d===void 0&&!("selected"in e||t.$$.bound[t.$$.props.selected])&&console.warn("<Tabs> was created without expected prop 'selected'")});const v=["visible","elem_id","elem_classes","selected"];Object.keys(e).forEach(a=>{!~v.indexOf(a)&&a.slice(0,2)!=="$$"&&a!=="slot"&&console.warn(`<Tabs> was created with unknown prop '${a}'`)});const ie=(a,w)=>{n(a.id),u("select",{value:a.name,index:w})};return t.$$set=a=>{"visible"in a&&s(0,l=a.visible),"elem_id"in a&&s(1,i=a.elem_id),"elem_classes"in a&&s(2,r=a.elem_classes),"selected"in a&&s(9,d=a.selected),"$$scope"in a&&s(10,c=a.$$scope)},t.$capture_state=()=>({TABS:L,setContext:G,createEventDispatcher:P,tick:le,writable:C,visible:l,elem_id:i,elem_classes:r,selected:d,tabs:_,selected_tab:h,selected_tab_index:b,dispatch:u,change_tab:n,$selected_tab_index:o,$selected_tab:f}),t.$inject_state=a=>{"visible"in a&&s(0,l=a.visible),"elem_id"in a&&s(1,i=a.elem_id),"elem_classes"in a&&s(2,r=a.elem_classes),"selected"in a&&s(9,d=a.selected),"tabs"in a&&s(3,_=a.tabs)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),t.$$.update=()=>{t.$$.dirty&512&&d!==null&&n(d)},[l,i,r,_,f,h,b,u,n,d,c,m,ie]}class oe extends Q{constructor(e){super(e),V(this,e,we,N,W,{visible:0,elem_id:1,elem_classes:2,selected:9}),g("SvelteRegisterComponent",{component:this,tagName:"Tabs",options:e,id:N.name})}get visible(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_classes(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_classes(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get selected(){throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set selected(e){throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function ce(t){let e;const s=t[5].default,o=X(s,t,t[9],null),f={c:function(){o&&o.c()},m:function(c,l){o&&o.m(c,l),e=!0},p:function(c,l){o&&o.p&&(!e||l&512)&&Z(o,s,c,c[9],e?$(s,c[9],l,null):x(c[9]),null)},i:function(c){e||(q(o,c),e=!0)},o:function(c){A(o,c),e=!1},d:function(c){o&&o.d(c)}};return g("SvelteRegisterBlock",{block:f,id:ce.name,type:"slot",source:'(12:0) <Tabs  {visible}  {elem_id}  {elem_classes}  bind:selected  on:change={() => gradio.dispatch(\\"change\\")}  on:select={(e) => gradio.dispatch(\\"select\\", e.detail)} >',ctx:t}),f}function D(t){let e,s,o;function f(l){t[6](l)}let m={visible:t[1],elem_id:t[2],elem_classes:t[3],$$slots:{default:[ce]},$$scope:{ctx:t}};t[0]!==void 0&&(m.selected=t[0]),e=new oe({props:m,$$inline:!0}),ue.push(()=>_e(e,"selected",f)),e.$on("change",t[7]),e.$on("select",t[8]);const c={c:function(){me(e.$$.fragment)},l:function(i){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(i,r){fe(e,i,r),o=!0},p:function(i,[r]){const d={};r&2&&(d.visible=i[1]),r&4&&(d.elem_id=i[2]),r&8&&(d.elem_classes=i[3]),r&512&&(d.$$scope={dirty:r,ctx:i}),!s&&r&1&&(s=!0,d.selected=i[0],be(()=>s=!1)),e.$set(d)},i:function(i){o||(q(e.$$.fragment,i),o=!0)},o:function(i){A(e.$$.fragment,i),o=!1},d:function(i){he(e,i)}};return g("SvelteRegisterBlock",{block:c,id:D.name,type:"component",source:"",ctx:t}),c}function ge(t,e,s){let{$$slots:o={},$$scope:f}=e;Y("StaticTabs",o,["default"]);const m=P();let{visible:c=!0}=e,{elem_id:l=""}=e,{elem_classes:i=[]}=e,{selected:r}=e,{gradio:d}=e;t.$$.on_mount.push(function(){r===void 0&&!("selected"in e||t.$$.bound[t.$$.props.selected])&&console.warn("<StaticTabs> was created without expected prop 'selected'"),d===void 0&&!("gradio"in e||t.$$.bound[t.$$.props.gradio])&&console.warn("<StaticTabs> was created without expected prop 'gradio'")});const _=["visible","elem_id","elem_classes","selected","gradio"];Object.keys(e).forEach(n=>{!~_.indexOf(n)&&n.slice(0,2)!=="$$"&&n!=="slot"&&console.warn(`<StaticTabs> was created with unknown prop '${n}'`)});function h(n){r=n,s(0,r)}const b=()=>d.dispatch("change"),u=n=>d.dispatch("select",n.detail);return t.$$set=n=>{"visible"in n&&s(1,c=n.visible),"elem_id"in n&&s(2,l=n.elem_id),"elem_classes"in n&&s(3,i=n.elem_classes),"selected"in n&&s(0,r=n.selected),"gradio"in n&&s(4,d=n.gradio),"$$scope"in n&&s(9,f=n.$$scope)},t.$capture_state=()=>({createEventDispatcher:P,Tabs:oe,dispatch:m,visible:c,elem_id:l,elem_classes:i,selected:r,gradio:d}),t.$inject_state=n=>{"visible"in n&&s(1,c=n.visible),"elem_id"in n&&s(2,l=n.elem_id),"elem_classes"in n&&s(3,i=n.elem_classes),"selected"in n&&s(0,r=n.selected),"gradio"in n&&s(4,d=n.gradio)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),t.$$.update=()=>{t.$$.dirty&1&&m("prop_change",{selected:r})},[r,c,l,i,d,o,h,b,u,f]}class pe extends Q{constructor(e){super(e),V(this,e,ge,D,W,{visible:1,elem_id:2,elem_classes:3,selected:0,gradio:4}),g("SvelteRegisterComponent",{component:this,tagName:"StaticTabs",options:e,id:D.name})}get visible(){throw new Error("<StaticTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<StaticTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<StaticTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<StaticTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_classes(){throw new Error("<StaticTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_classes(e){throw new Error("<StaticTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get selected(){throw new Error("<StaticTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set selected(e){throw new Error("<StaticTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get gradio(){throw new Error("<StaticTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set gradio(e){throw new Error("<StaticTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Te=pe;export{Te as S,L as T};
//# sourceMappingURL=StaticTabs-248b81e8.js.map
