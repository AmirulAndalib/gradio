import{SvelteComponentDev as I,init as X,safe_not_equal as A,dispatch_dev as v,validate_slots as F,onDestroy as U,element as D,create_component as y,space as R,attr_dev as S,toggle_class as N,add_location as W,insert_dev as E,append_dev as L,mount_component as k,listen_dev as oe,transition_in as _,group_outros as x,transition_out as p,check_outros as $,detach_dev as P,destroy_component as C,add_render_callback as se,create_bidirectional_transition as z,validate_store as ye,component_subscribe as ke,afterUpdate as te,assign as Ce,empty as Se,get_spread_update as Ee,get_spread_object as Pe,binding_callbacks as je,bind as Be,add_flush_callback as De}from"../../../node/dev/svelte-internal.js";import{X as H,S as ie}from"./index-168e7816.js";import{C as re,a as ee}from"./Widgets.svelte_svelte_type_style_lang-a502000a.js";import{f as O,B as ce}from"./Button-e33227ec.js";import{C as ae,a as G}from"./Copy-e8e2bc99.js";import{D as le}from"./Download-39664f40.js";import{B as ue}from"./BlockLabel-2ee7f826.js";import{E as fe}from"./Empty-fa07e7fd.js";const J="Users/peterallen/Projects/gradio/js/code/shared/Copy.svelte";function K(n){let e,t,c,l;t=new G({$$inline:!0});const s={c:function(){e=D("span"),y(t.$$.fragment),S(e,"class","check svelte-qjb524"),W(e,J,34,2,736)},m:function(i,o){E(i,e,o),k(t,e,null),l=!0},i:function(i){l||(_(t.$$.fragment,i),i&&se(()=>{l&&(c||(c=z(e,O,{},!0)),c.run(1))}),l=!0)},o:function(i){p(t.$$.fragment,i),i&&(c||(c=z(e,O,{},!1)),c.run(0)),l=!1},d:function(i){i&&P(e),C(t),i&&c&&c.end()}};return v("SvelteRegisterBlock",{block:s,id:K.name,type:"if",source:"(31:1) {#if copied}",ctx:n}),s}function M(n){let e,t,c,l,s,r,i;c=new ae({$$inline:!0});let o=n[0]&&K(n);const d={c:function(){e=D("button"),t=D("span"),y(c.$$.fragment),l=R(),o&&o.c(),S(t,"class","copy-text"),N(t,"copied",n[0]),W(t,J,31,1,650),S(e,"title","copy"),S(e,"class","svelte-qjb524"),W(e,J,29,0,580)},l:function(a){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(a,w){E(a,e,w),L(e,t),k(c,t,null),L(e,l),o&&o.m(e,null),s=!0,r||(i=oe(e,"click",n[1],!1,!1,!1,!1),r=!0)},p:function(a,[w]){(!s||w&1)&&N(t,"copied",a[0]),a[0]?o?w&1&&_(o,1):(o=K(a),o.c(),_(o,1),o.m(e,null)):o&&(x(),p(o,1,1,()=>{o=null}),$())},i:function(a){s||(_(c.$$.fragment,a),_(o),s=!0)},o:function(a){p(c.$$.fragment,a),p(o),s=!1},d:function(a){a&&P(e),C(c),o&&o.d(),r=!1,i()}};return v("SvelteRegisterBlock",{block:d,id:M.name,type:"component",source:"",ctx:n}),d}function Re(n,e,t){let{$$slots:c={},$$scope:l}=e;F("Copy",c,[]);let s=!1,{value:r}=e,i;function o(){t(0,s=!0),i&&clearTimeout(i),i=setTimeout(()=>{t(0,s=!1)},2e3)}async function d(){"clipboard"in navigator&&(await navigator.clipboard.writeText(r),o())}U(()=>{i&&clearTimeout(i)}),n.$$.on_mount.push(function(){r===void 0&&!("value"in e||n.$$.bound[n.$$.props.value])&&console.warn("<Copy> was created without expected prop 'value'")});const f=["value"];return Object.keys(e).forEach(a=>{!~f.indexOf(a)&&a.slice(0,2)!=="$$"&&a!=="slot"&&console.warn(`<Copy> was created with unknown prop '${a}'`)}),n.$$set=a=>{"value"in a&&t(2,r=a.value)},n.$capture_state=()=>({onDestroy:U,fade:O,Copy:ae,Check:G,copied:s,value:r,timer:i,copy_feedback:o,handle_copy:d}),n.$inject_state=a=>{"copied"in a&&t(0,s=a.copied),"value"in a&&t(2,r=a.value),"timer"in a&&(i=a.timer)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[s,d,r]}class de extends I{constructor(e){super(e),X(this,e,Re,M,A,{value:2}),v("SvelteRegisterComponent",{component:this,tagName:"Copy_1",options:e,id:M.name})}get value(){throw new Error("<Copy>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Copy>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const me="Users/peterallen/Projects/gradio/js/code/shared/Download.svelte";function Q(n){let e,t,c,l;t=new G({$$inline:!0});const s={c:function(){e=D("span"),y(t.$$.fragment),S(e,"class","check svelte-11uuqle"),W(e,me,60,2,1129)},m:function(i,o){E(i,e,o),k(t,e,null),l=!0},i:function(i){l||(_(t.$$.fragment,i),i&&se(()=>{l&&(c||(c=z(e,O,{},!0)),c.run(1))}),l=!0)},o:function(i){p(t.$$.fragment,i),i&&(c||(c=z(e,O,{},!1)),c.run(0)),l=!1},d:function(i){i&&P(e),C(t),i&&c&&c.end()}};return v("SvelteRegisterBlock",{block:s,id:Q.name,type:"if",source:"(53:1) {#if copied}",ctx:n}),s}function V(n){let e,t,c,l,s,r,i;t=new le({$$inline:!0});let o=n[0]&&Q(n);const d={c:function(){e=D("a"),y(t.$$.fragment),c=R(),o&&o.c(),S(e,"download",l="file."+n[2]),S(e,"href",n[1]),S(e,"class","svelte-11uuqle"),N(e,"copied",n[0]),W(e,me,52,0,1008)},l:function(a){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(a,w){E(a,e,w),k(t,e,null),L(e,c),o&&o.m(e,null),s=!0,r||(i=oe(e,"click",n[3],!1,!1,!1,!1),r=!0)},p:function(a,[w]){a[0]?o?w&1&&_(o,1):(o=Q(a),o.c(),_(o,1),o.m(e,null)):o&&(x(),p(o,1,1,()=>{o=null}),$()),(!s||w&4&&l!==(l="file."+a[2]))&&S(e,"download",l),(!s||w&2)&&S(e,"href",a[1]),(!s||w&1)&&N(e,"copied",a[0])},i:function(a){s||(_(t.$$.fragment,a),_(o),s=!0)},o:function(a){p(t.$$.fragment,a),p(o),s=!1},d:function(a){a&&P(e),C(t),o&&o.d(),r=!1,i()}};return v("SvelteRegisterBlock",{block:d,id:V.name,type:"component",source:"",ctx:n}),d}function ne(n){return{py:"py",python:"py",md:"md",markdown:"md",json:"json",html:"html",css:"css",js:"js",javascript:"js",ts:"ts",typescript:"ts",yaml:"yaml",yml:"yml",dockerfile:"dockerfile",sh:"sh",shell:"sh",r:"r"}[n]||"txt"}function We(n,e,t){let c,l,{$$slots:s={},$$scope:r}=e;F("Download",s,[]);let{value:i}=e,{language:o}=e,d=!1,f;function a(){t(0,d=!0),f&&clearTimeout(f),f=setTimeout(()=>{t(0,d=!1)},2e3)}U(()=>{f&&clearTimeout(f)}),n.$$.on_mount.push(function(){i===void 0&&!("value"in e||n.$$.bound[n.$$.props.value])&&console.warn("<Download> was created without expected prop 'value'"),o===void 0&&!("language"in e||n.$$.bound[n.$$.props.language])&&console.warn("<Download> was created without expected prop 'language'")});const w=["value","language"];return Object.keys(e).forEach(m=>{!~w.indexOf(m)&&m.slice(0,2)!=="$$"&&m!=="slot"&&console.warn(`<Download> was created with unknown prop '${m}'`)}),n.$$set=m=>{"value"in m&&t(4,i=m.value),"language"in m&&t(5,o=m.language)},n.$capture_state=()=>({onDestroy:U,fade:O,Download:le,Check:G,value:i,language:o,get_ext_for_type:ne,copied:d,timer:f,copy_feedback:a,download_value:l,ext:c}),n.$inject_state=m=>{"value"in m&&t(4,i=m.value),"language"in m&&t(5,o=m.language),"copied"in m&&t(0,d=m.copied),"timer"in m&&(f=m.timer),"download_value"in m&&t(1,l=m.download_value),"ext"in m&&t(2,c=m.ext)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&32&&t(2,c=ne(o)),n.$$.dirty&16&&t(1,l=URL.createObjectURL(new Blob([i])))},[d,l,c,a,i,o]}class ge extends I{constructor(e){super(e),X(this,e,We,V,A,{value:4,language:5}),v("SvelteRegisterComponent",{component:this,tagName:"Download_1",options:e,id:V.name})}get value(){throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get language(){throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set language(e){throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Oe="Users/peterallen/Projects/gradio/js/code/shared/Widgets.svelte";function Y(n){let e,t,c,l,s;t=new ge({props:{value:n[0],language:n[1]},$$inline:!0}),l=new de({props:{value:n[0]},$$inline:!0});const r={c:function(){e=D("div"),y(t.$$.fragment),c=R(),y(l.$$.fragment),S(e,"class","svelte-1bqqv16"),W(e,Oe,8,0,144)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,d){E(o,e,d),k(t,e,null),L(e,c),k(l,e,null),s=!0},p:function(o,[d]){const f={};d&1&&(f.value=o[0]),d&2&&(f.language=o[1]),t.$set(f);const a={};d&1&&(a.value=o[0]),l.$set(a)},i:function(o){s||(_(t.$$.fragment,o),_(l.$$.fragment,o),s=!0)},o:function(o){p(t.$$.fragment,o),p(l.$$.fragment,o),s=!1},d:function(o){o&&P(e),C(t),C(l)}};return v("SvelteRegisterBlock",{block:r,id:Y.name,type:"component",source:"",ctx:n}),r}function Te(n,e,t){let{$$slots:c={},$$scope:l}=e;F("Widgets",c,[]);let{value:s}=e,{language:r}=e;n.$$.on_mount.push(function(){s===void 0&&!("value"in e||n.$$.bound[n.$$.props.value])&&console.warn("<Widgets> was created without expected prop 'value'"),r===void 0&&!("language"in e||n.$$.bound[n.$$.props.language])&&console.warn("<Widgets> was created without expected prop 'language'")});const i=["value","language"];return Object.keys(e).forEach(o=>{!~i.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Widgets> was created with unknown prop '${o}'`)}),n.$$set=o=>{"value"in o&&t(0,s=o.value),"language"in o&&t(1,r=o.language)},n.$capture_state=()=>({Copy:de,Download:ge,value:s,language:r}),n.$inject_state=o=>{"value"in o&&t(0,s=o.value),"language"in o&&t(1,r=o.language)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),[s,r]}class we extends I{constructor(e){super(e),X(this,e,Te,Y,A,{value:0,language:1}),v("SvelteRegisterComponent",{component:this,tagName:"Widgets",options:e,id:Y.name})}get value(){throw new Error("<Widgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Widgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get language(){throw new Error("<Widgets>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set language(e){throw new Error("<Widgets>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}function _e(n){let e,t,c,l,s;e=new we({props:{language:n[1],value:n[0]},$$inline:!0});function r(d){n[13](d)}let i={language:n[1],lines:n[2],dark_mode:n[9],readonly:!0};n[0]!==void 0&&(i.value=n[0]),c=new re({props:i,$$inline:!0}),je.push(()=>Be(c,"value",r));const o={c:function(){y(e.$$.fragment),t=R(),y(c.$$.fragment)},m:function(f,a){k(e,f,a),E(f,t,a),k(c,f,a),s=!0},p:function(f,a){const w={};a&2&&(w.language=f[1]),a&1&&(w.value=f[0]),e.$set(w);const m={};a&2&&(m.language=f[1]),a&4&&(m.lines=f[2]),!l&&a&1&&(l=!0,m.value=f[0],De(()=>l=!1)),c.$set(m)},i:function(f){s||(_(e.$$.fragment,f),_(c.$$.fragment,f),s=!0)},o:function(f){p(e.$$.fragment,f),p(c.$$.fragment,f),s=!1},d:function(f){f&&P(t),C(e,f),C(c,f)}};return v("SvelteRegisterBlock",{block:o,id:_e.name,type:"else",source:"(41:1) {:else}",ctx:n}),o}function he(n){let e,t;e=new fe({props:{unpadded_box:!0,size:"large",$$slots:{default:[pe]},$$scope:{ctx:n}},$$inline:!0});const c={c:function(){y(e.$$.fragment)},m:function(s,r){k(e,s,r),t=!0},p:function(s,r){const i={};r&65536&&(i.$$scope={dirty:r,ctx:s}),e.$set(i)},i:function(s){t||(_(e.$$.fragment,s),t=!0)},o:function(s){p(e.$$.fragment,s),t=!1},d:function(s){C(e,s)}};return v("SvelteRegisterBlock",{block:c,id:he.name,type:"if",source:"(37:1) {#if !value}",ctx:n}),c}function pe(n){let e,t;e=new ee({$$inline:!0});const c={c:function(){y(e.$$.fragment)},m:function(s,r){k(e,s,r),t=!0},i:function(s){t||(_(e.$$.fragment,s),t=!0)},o:function(s){p(e.$$.fragment,s),t=!1},d:function(s){C(e,s)}};return v("SvelteRegisterBlock",{block:c,id:pe.name,type:"slot",source:'(38:2) <Empty unpadded_box={true} size=\\"large\\">',ctx:n}),c}function be(n){let e,t,c,l,s,r,i,o;const d=[n[8]];let f={};for(let b=0;b<d.length;b+=1)f=Ce(f,d[b]);e=new ie({props:f,$$inline:!0}),c=new ue({props:{Icon:ee,show_label:n[7],label:n[6],float:!1},$$inline:!0});const a=[he,_e],w=[];function m(b,g){return b[0]?1:0}s=m(n),r=w[s]=a[s](n);const j={c:function(){y(e.$$.fragment),t=R(),y(c.$$.fragment),l=R(),r.c(),i=Se()},m:function(g,h){k(e,g,h),E(g,t,h),k(c,g,h),E(g,l,h),w[s].m(g,h),E(g,i,h),o=!0},p:function(g,h){const T=h&256?Ee(d,[Pe(g[8])]):{};e.$set(T);const B={};h&128&&(B.show_label=g[7]),h&64&&(B.label=g[6]),c.$set(B);let q=s;s=m(g),s===q?w[s].p(g,h):(x(),p(w[q],1,1,()=>{w[q]=null}),$(),r=w[s],r?r.p(g,h):(r=w[s]=a[s](g),r.c()),_(r,1),r.m(i.parentNode,i))},i:function(g){o||(_(e.$$.fragment,g),_(c.$$.fragment,g),_(r),o=!0)},o:function(g){p(e.$$.fragment,g),p(c.$$.fragment,g),p(r),o=!1},d:function(g){g&&(P(t),P(l),P(i)),C(e,g),C(c,g),w[s].d(g)}};return v("SvelteRegisterBlock",{block:j,id:be.name,type:"slot",source:'(32:0) <Block variant={\\"solid\\"} padding={false} {elem_id} {elem_classes} {visible}>',ctx:n}),j}function Z(n){let e,t;e=new ce({props:{variant:"solid",padding:!1,elem_id:n[3],elem_classes:n[4],visible:n[5],$$slots:{default:[be]},$$scope:{ctx:n}},$$inline:!0});const c={c:function(){y(e.$$.fragment)},l:function(s){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,r){k(e,s,r),t=!0},p:function(s,[r]){const i={};r&8&&(i.elem_id=s[3]),r&16&&(i.elem_classes=s[4]),r&32&&(i.visible=s[5]),r&65991&&(i.$$scope={dirty:r,ctx:s}),e.$set(i)},i:function(s){t||(_(e.$$.fragment,s),t=!0)},o:function(s){p(e.$$.fragment,s),t=!1},d:function(s){C(e,s)}};return v("SvelteRegisterBlock",{block:c,id:Z.name,type:"component",source:"",ctx:n}),c}function qe(n,e,t){let c;ye(H,"_"),ke(n,H,u=>t(14,c=u));let{$$slots:l={},$$scope:s}=e;F("StaticCode",l,[]);let{value:r=""}=e,{value_is_output:i=!1}=e,{language:o=""}=e,{lines:d=5}=e,{target:f}=e,{elem_id:a=""}=e,{elem_classes:w=[]}=e,{visible:m=!0}=e,{label:j=c("code.code")}=e,{show_label:b=!0}=e,{loading_status:g}=e,{gradio:h}=e,T=f.classList.contains("dark");function B(){h.dispatch("change",r),i||h.dispatch("input")}te(()=>{t(10,i=!1)}),n.$$.on_mount.push(function(){f===void 0&&!("target"in e||n.$$.bound[n.$$.props.target])&&console.warn("<StaticCode> was created without expected prop 'target'"),g===void 0&&!("loading_status"in e||n.$$.bound[n.$$.props.loading_status])&&console.warn("<StaticCode> was created without expected prop 'loading_status'"),h===void 0&&!("gradio"in e||n.$$.bound[n.$$.props.gradio])&&console.warn("<StaticCode> was created without expected prop 'gradio'")});const q=["value","value_is_output","language","lines","target","elem_id","elem_classes","visible","label","show_label","loading_status","gradio"];Object.keys(e).forEach(u=>{!~q.indexOf(u)&&u.slice(0,2)!=="$$"&&u!=="slot"&&console.warn(`<StaticCode> was created with unknown prop '${u}'`)});function ve(u){r=u,t(0,r)}return n.$$set=u=>{"value"in u&&t(0,r=u.value),"value_is_output"in u&&t(10,i=u.value_is_output),"language"in u&&t(1,o=u.language),"lines"in u&&t(2,d=u.lines),"target"in u&&t(11,f=u.target),"elem_id"in u&&t(3,a=u.elem_id),"elem_classes"in u&&t(4,w=u.elem_classes),"visible"in u&&t(5,m=u.visible),"label"in u&&t(6,j=u.label),"show_label"in u&&t(7,b=u.show_label),"loading_status"in u&&t(8,g=u.loading_status),"gradio"in u&&t(12,h=u.gradio)},n.$capture_state=()=>({afterUpdate:te,_:H,Code:re,Widget:we,StatusTracker:ie,Block:ce,BlockLabel:ue,Empty:fe,CodeIcon:ee,value:r,value_is_output:i,language:o,lines:d,target:f,elem_id:a,elem_classes:w,visible:m,label:j,show_label:b,loading_status:g,gradio:h,dark_mode:T,handle_change:B,$_:c}),n.$inject_state=u=>{"value"in u&&t(0,r=u.value),"value_is_output"in u&&t(10,i=u.value_is_output),"language"in u&&t(1,o=u.language),"lines"in u&&t(2,d=u.lines),"target"in u&&t(11,f=u.target),"elem_id"in u&&t(3,a=u.elem_id),"elem_classes"in u&&t(4,w=u.elem_classes),"visible"in u&&t(5,m=u.visible),"label"in u&&t(6,j=u.label),"show_label"in u&&t(7,b=u.show_label),"loading_status"in u&&t(8,g=u.loading_status),"gradio"in u&&t(12,h=u.gradio),"dark_mode"in u&&t(9,T=u.dark_mode)},e&&"$$inject"in e&&n.$inject_state(e.$$inject),n.$$.update=()=>{n.$$.dirty&1&&B()},[r,o,d,a,w,m,j,b,g,T,i,f,h,ve]}class Ue extends I{constructor(e){super(e),X(this,e,qe,Z,A,{value:0,value_is_output:10,language:1,lines:2,target:11,elem_id:3,elem_classes:4,visible:5,label:6,show_label:7,loading_status:8,gradio:12}),v("SvelteRegisterComponent",{component:this,tagName:"StaticCode",options:e,id:Z.name})}get value(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value_is_output(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value_is_output(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get language(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set language(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get lines(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set lines(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get target(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set target(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_id(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_id(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get elem_classes(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set elem_classes(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get visible(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set visible(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get show_label(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get loading_status(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set loading_status(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get gradio(){throw new Error("<StaticCode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set gradio(e){throw new Error("<StaticCode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const He=Ue;export{He as default};
//# sourceMappingURL=index-5c4d9e7c.js.map
