import{SvelteComponentDev as A,init as z,safe_not_equal as q,dispatch_dev as _,ensure_array_like_dev as N,validate_slots as M,element as k,create_component as O,space as j,attr_dev as h,add_location as b,insert_dev as P,mount_component as G,append_dev as w,transition_in as B,transition_out as T,detach_dev as S,destroy_component as D,destroy_each as H,text as C,set_data_dev as I,svg_element as J,toggle_class as K,afterUpdate as ke,src_url_equal as ye,binding_callbacks as Ee,construct_svelte_component_dev as Pe,empty as Te,group_outros as Oe,check_outros as Ge,assign as Ve,get_spread_update as We,get_spread_object as Xe}from"../../../node/dev/svelte-internal.js";import"./index-168e7816.js";import"./Button-e33227ec.js";import{B as x}from"./BlockTitle-87da8f73.js";import"./Info-05947842.js";const y=t=>{var e=null;return t<0?e=[52,152,219]:e=[231,76,60],Ze(Ye(Math.abs(t),[255,255,255],e))},Ye=(t,e,n)=>{t>1&&(t=1),t=Math.sqrt(t);var a=[0,0,0],l;for(l=0;l<3;l++)a[l]=Math.round(e[l]*(1-t)+n[l]*t);return a},Ze=t=>"rgb("+t[0]+", "+t[1]+", "+t[2]+")";function W(t,e,n,a,l){var r=a/l,c=e/n,u=0,s=0,o=t?r>c:r<c;return o?(u=e,s=u/r):(s=n,u=s*r),{width:u,height:s,x:(e-u)/2,y:(n-s)/2}}const X="src/components/Interpretation/InterpretationComponents/Number.svelte";function Se(t,e,n){const a=t.slice();return a[2]=e[n],a}function De(t){let e;const n={c:function(){e=C(t[1])},m:function(l,r){P(l,e,r)},p:function(l,r){r&2&&I(e,l[1])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:De.name,type:"slot",source:"(8:1) <BlockTitle>",ctx:t}),n}function Y(t){let e,n=t[2][0]+"",a,l,r;const c={c:function(){e=k("div"),a=C(n),l=j(),h(e,"class","item svelte-1i22aby"),h(e,"style",r="background-color: "+y(t[2][1])),b(e,X,12,3,297)},m:function(s,o){P(s,e,o),w(e,a),w(e,l)},p:function(s,o){o&1&&n!==(n=s[2][0]+"")&&I(a,n),o&1&&r!==(r="background-color: "+y(s[2][1]))&&h(e,"style",r)},d:function(s){s&&S(e)}};return _("SvelteRegisterBlock",{block:c,id:Y.name,type:"each",source:"(10:2) {#each interpretation as interpret_value}",ctx:t}),c}function Z(t){let e,n,a,l,r;n=new x({props:{$$slots:{default:[De]},$$scope:{ctx:t}},$$inline:!0});let c=N(t[0]),u=[];for(let o=0;o<c.length;o+=1)u[o]=Y(Se(t,c,o));const s={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("div");for(let i=0;i<u.length;i+=1)u[i].c();h(l,"class","range svelte-1i22aby"),b(l,X,10,1,230),h(e,"class","input-number svelte-1i22aby"),b(e,X,8,0,168)},l:function(i){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(i,f){P(i,e,f),G(n,e,null),w(e,a),w(e,l);for(let m=0;m<u.length;m+=1)u[m]&&u[m].m(l,null);r=!0},p:function(i,[f]){const m={};if(f&34&&(m.$$scope={dirty:f,ctx:i}),n.$set(m),f&1){c=N(i[0]);let d;for(d=0;d<c.length;d+=1){const v=Se(i,c,d);u[d]?u[d].p(v,f):(u[d]=Y(v),u[d].c(),u[d].m(l,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}},i:function(i){r||(B(n.$$.fragment,i),r=!0)},o:function(i){T(n.$$.fragment,i),r=!1},d:function(i){i&&S(e),D(n),H(u,i)}};return _("SvelteRegisterBlock",{block:s,id:Z.name,type:"component",source:"",ctx:t}),s}function $e(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Number",a,[]);let{interpretation:r}=e,{label:c=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Number> was created without expected prop 'interpretation'")});const u=["interpretation","label"];return Object.keys(e).forEach(s=>{!~u.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<Number> was created with unknown prop '${s}'`)}),t.$$set=s=>{"interpretation"in s&&n(0,r=s.interpretation),"label"in s&&n(1,c=s.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,interpretation:r,label:c}),t.$inject_state=s=>{"interpretation"in s&&n(0,r=s.interpretation),"label"in s&&n(1,c=s.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c]}class et extends A{constructor(e){super(e),z(this,e,$e,Z,q,{interpretation:0,label:1}),_("SvelteRegisterComponent",{component:this,tagName:"Number",options:e,id:Z.name})}get interpretation(){throw new Error("<Number>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Number>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Number>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Number>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const $="src/components/Interpretation/InterpretationComponents/Dropdown.svelte";function je(t,e,n){const a=t.slice();return a[3]=e[n],a[5]=n,a}function Ae(t){let e;const n={c:function(){e=C(t[2])},m:function(l,r){P(l,e,r)},p:function(l,r){r&4&&I(e,l[2])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:Ae.name,type:"slot",source:"(9:1) <BlockTitle>",ctx:t}),n}function ee(t){let e,n=t[3]+"",a,l,r;const c={c:function(){e=k("li"),a=C(n),l=j(),h(e,"class","dropdown-item svelte-8srmgv"),h(e,"style",r="background-color: "+y(t[0][t[5]])),b(e,$,13,3,290)},m:function(s,o){P(s,e,o),w(e,a),w(e,l)},p:function(s,o){o&2&&n!==(n=s[3]+"")&&I(a,n),o&1&&r!==(r="background-color: "+y(s[0][s[5]]))&&h(e,"style",r)},d:function(s){s&&S(e)}};return _("SvelteRegisterBlock",{block:c,id:ee.name,type:"each",source:"(11:2) {#each choices as choice, i}",ctx:t}),c}function te(t){let e,n,a,l,r;n=new x({props:{$$slots:{default:[Ae]},$$scope:{ctx:t}},$$inline:!0});let c=N(t[1]),u=[];for(let o=0;o<c.length;o+=1)u[o]=ee(je(t,c,o));const s={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("ul");for(let i=0;i<u.length;i+=1)u[i].c();h(l,"class","dropdown-menu svelte-8srmgv"),b(l,$,11,1,229),b(e,$,9,0,188)},l:function(i){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(i,f){P(i,e,f),G(n,e,null),w(e,a),w(e,l);for(let m=0;m<u.length;m+=1)u[m]&&u[m].m(l,null);r=!0},p:function(i,[f]){const m={};if(f&68&&(m.$$scope={dirty:f,ctx:i}),n.$set(m),f&3){c=N(i[1]);let d;for(d=0;d<c.length;d+=1){const v=je(i,c,d);u[d]?u[d].p(v,f):(u[d]=ee(v),u[d].c(),u[d].m(l,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}},i:function(i){r||(B(n.$$.fragment,i),r=!0)},o:function(i){T(n.$$.fragment,i),r=!1},d:function(i){i&&S(e),D(n),H(u,i)}};return _("SvelteRegisterBlock",{block:s,id:te.name,type:"component",source:"",ctx:t}),s}function tt(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Dropdown",a,[]);let{interpretation:r}=e,{choices:c}=e,{label:u=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Dropdown> was created without expected prop 'interpretation'"),c===void 0&&!("choices"in e||t.$$.bound[t.$$.props.choices])&&console.warn("<Dropdown> was created without expected prop 'choices'")});const s=["interpretation","choices","label"];return Object.keys(e).forEach(o=>{!~s.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Dropdown> was created with unknown prop '${o}'`)}),t.$$set=o=>{"interpretation"in o&&n(0,r=o.interpretation),"choices"in o&&n(1,c=o.choices),"label"in o&&n(2,u=o.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,interpretation:r,choices:c,label:u}),t.$inject_state=o=>{"interpretation"in o&&n(0,r=o.interpretation),"choices"in o&&n(1,c=o.choices),"label"in o&&n(2,u=o.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c,u]}class nt extends A{constructor(e){super(e),z(this,e,tt,te,q,{interpretation:0,choices:1,label:2}),_("SvelteRegisterComponent",{component:this,tagName:"Dropdown",options:e,id:te.name})}get interpretation(){throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get choices(){throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set choices(e){throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const F="src/components/Interpretation/InterpretationComponents/Checkbox.svelte";function ze(t){let e;const n={c:function(){e=C(t[0])},m:function(l,r){P(l,e,r)},p:function(l,r){r&1&&I(e,l[0])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:ze.name,type:"slot",source:"(9:1) <BlockTitle>",ctx:t}),n}function ne(t){let e,n,a,l,r,c,u,s,o,i,f,m,d;n=new x({props:{$$slots:{default:[ze]},$$scope:{ctx:t}},$$inline:!0});const v={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("button"),r=k("div"),u=j(),s=k("div"),o=J("svg"),i=J("line"),f=J("line"),h(r,"class","checkbox svelte-12x17m6"),h(r,"style",c="background-color: "+y(t[2][0])),b(r,F,12,2,312),h(i,"x1","-7.5"),h(i,"y1","0"),h(i,"x2","-2.5"),h(i,"y2","5"),h(i,"stroke","black"),h(i,"stroke-width","4"),h(i,"stroke-linecap","round"),b(i,F,21,4,550),h(f,"x1","-2.5"),h(f,"y1","5"),h(f,"x2","7.5"),h(f,"y2","-7.5"),h(f,"stroke","black"),h(f,"stroke-width","4"),h(f,"stroke-linecap","round"),b(f,F,30,4,691),h(o,"viewBox","-10 -10 20 20"),h(o,"class","svelte-12x17m6"),b(o,F,20,3,516),h(s,"class","checkbox svelte-12x17m6"),h(s,"style",m="background-color: "+y(t[2][1])),b(s,F,16,2,414),h(l,"class","checkbox-item svelte-12x17m6"),K(l,"selected",t[1]),b(l,F,11,1,253),h(e,"class","input-checkbox svelte-12x17m6"),b(e,F,9,0,189)},l:function(g){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(g,E){P(g,e,E),G(n,e,null),w(e,a),w(e,l),w(l,r),w(l,u),w(l,s),w(s,o),w(o,i),w(o,f),d=!0},p:function(g,[E]){const R={};E&9&&(R.$$scope={dirty:E,ctx:g}),n.$set(R),(!d||E&4&&c!==(c="background-color: "+y(g[2][0])))&&h(r,"style",c),(!d||E&4&&m!==(m="background-color: "+y(g[2][1])))&&h(s,"style",m),(!d||E&2)&&K(l,"selected",g[1])},i:function(g){d||(B(n.$$.fragment,g),d=!0)},o:function(g){T(n.$$.fragment,g),d=!1},d:function(g){g&&S(e),D(n)}};return _("SvelteRegisterBlock",{block:v,id:ne.name,type:"component",source:"",ctx:t}),v}function ot(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Checkbox",a,[]);let{label:r=""}=e,{original:c}=e,{interpretation:u}=e;t.$$.on_mount.push(function(){c===void 0&&!("original"in e||t.$$.bound[t.$$.props.original])&&console.warn("<Checkbox> was created without expected prop 'original'"),u===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Checkbox> was created without expected prop 'interpretation'")});const s=["label","original","interpretation"];return Object.keys(e).forEach(o=>{!~s.indexOf(o)&&o.slice(0,2)!=="$$"&&o!=="slot"&&console.warn(`<Checkbox> was created with unknown prop '${o}'`)}),t.$$set=o=>{"label"in o&&n(0,r=o.label),"original"in o&&n(1,c=o.original),"interpretation"in o&&n(2,u=o.interpretation)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,label:r,original:c,interpretation:u}),t.$inject_state=o=>{"label"in o&&n(0,r=o.label),"original"in o&&n(1,c=o.original),"interpretation"in o&&n(2,u=o.interpretation)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c,u]}class it extends A{constructor(e){super(e),z(this,e,ot,ne,q,{label:0,original:1,interpretation:2}),_("SvelteRegisterComponent",{component:this,tagName:"Checkbox",options:e,id:ne.name})}get label(){throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get original(){throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set original(e){throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const U="src/components/Interpretation/InterpretationComponents/CheckboxGroup.svelte";function xe(t,e,n){const a=t.slice();return a[4]=e[n],a[6]=n,a}function qe(t){let e;const n={c:function(){e=C(t[3])},m:function(l,r){P(l,e,r)},p:function(l,r){r&8&&I(e,l[3])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:qe.name,type:"slot",source:"(10:1) <BlockTitle>",ctx:t}),n}function oe(t){let e,n,a,l,r,c,u,s,o,i,f=t[4]+"",m,d;const v={c:function(){e=k("button"),n=k("div"),l=j(),r=k("div"),c=J("svg"),u=J("line"),s=J("line"),i=j(),m=C(f),d=j(),h(n,"class","checkbox svelte-1sysy0"),h(n,"style",a="background-color: "+y(t[1][t[6]][0])),b(n,U,14,3,387),h(u,"x1","-7.5"),h(u,"y1","0"),h(u,"x2","-2.5"),h(u,"y2","5"),h(u,"stroke","black"),h(u,"stroke-width","4"),h(u,"stroke-linecap","round"),b(u,U,23,5,640),h(s,"x1","-2.5"),h(s,"y1","5"),h(s,"x2","7.5"),h(s,"y2","-7.5"),h(s,"stroke","black"),h(s,"stroke-width","4"),h(s,"stroke-linecap","round"),b(s,U,32,5,790),h(c,"viewBox","-10 -10 20 20"),h(c,"class","svelte-1sysy0"),b(c,U,22,4,605),h(r,"class","checkbox svelte-1sysy0"),h(r,"style",o="background-color: "+y(t[1][t[6]][1])),b(r,U,18,3,496),h(e,"class","checkbox-item svelte-1sysy0"),K(e,"selected",t[0].includes(t[4])),b(e,U,13,2,310)},m:function(g,E){P(g,e,E),w(e,n),w(e,l),w(e,r),w(r,c),w(c,u),w(c,s),w(e,i),w(e,m),w(e,d)},p:function(g,E){E&2&&a!==(a="background-color: "+y(g[1][g[6]][0]))&&h(n,"style",a),E&2&&o!==(o="background-color: "+y(g[1][g[6]][1]))&&h(r,"style",o),E&4&&f!==(f=g[4]+"")&&I(m,f),E&5&&K(e,"selected",g[0].includes(g[4]))},d:function(g){g&&S(e)}};return _("SvelteRegisterBlock",{block:v,id:oe.name,type:"each",source:"(11:1) {#each choices as choice, i}",ctx:t}),v}function ie(t){let e,n,a,l;n=new x({props:{$$slots:{default:[qe]},$$scope:{ctx:t}},$$inline:!0});let r=N(t[2]),c=[];for(let s=0;s<r.length;s+=1)c[s]=oe(xe(t,r,s));const u={c:function(){e=k("div"),O(n.$$.fragment),a=j();for(let o=0;o<c.length;o+=1)c[o].c();h(e,"class","input-checkbox-group svelte-1sysy0"),b(e,U,10,0,209)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,i){P(o,e,i),G(n,e,null),w(e,a);for(let f=0;f<c.length;f+=1)c[f]&&c[f].m(e,null);l=!0},p:function(o,[i]){const f={};if(i&136&&(f.$$scope={dirty:i,ctx:o}),n.$set(f),i&7){r=N(o[2]);let m;for(m=0;m<r.length;m+=1){const d=xe(o,r,m);c[m]?c[m].p(d,i):(c[m]=oe(d),c[m].c(),c[m].m(e,null))}for(;m<c.length;m+=1)c[m].d(1);c.length=r.length}},i:function(o){l||(B(n.$$.fragment,o),l=!0)},o:function(o){T(n.$$.fragment,o),l=!1},d:function(o){o&&S(e),D(n),H(c,o)}};return _("SvelteRegisterBlock",{block:u,id:ie.name,type:"component",source:"",ctx:t}),u}function rt(t,e,n){let{$$slots:a={},$$scope:l}=e;M("CheckboxGroup",a,[]);let{original:r}=e,{interpretation:c}=e,{choices:u}=e,{label:s=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("original"in e||t.$$.bound[t.$$.props.original])&&console.warn("<CheckboxGroup> was created without expected prop 'original'"),c===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<CheckboxGroup> was created without expected prop 'interpretation'"),u===void 0&&!("choices"in e||t.$$.bound[t.$$.props.choices])&&console.warn("<CheckboxGroup> was created without expected prop 'choices'")});const o=["original","interpretation","choices","label"];return Object.keys(e).forEach(i=>{!~o.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<CheckboxGroup> was created with unknown prop '${i}'`)}),t.$$set=i=>{"original"in i&&n(0,r=i.original),"interpretation"in i&&n(1,c=i.interpretation),"choices"in i&&n(2,u=i.choices),"label"in i&&n(3,s=i.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,original:r,interpretation:c,choices:u,label:s}),t.$inject_state=i=>{"original"in i&&n(0,r=i.original),"interpretation"in i&&n(1,c=i.interpretation),"choices"in i&&n(2,u=i.choices),"label"in i&&n(3,s=i.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c,u,s]}class ct extends A{constructor(e){super(e),z(this,e,rt,ie,q,{original:0,interpretation:1,choices:2,label:3}),_("SvelteRegisterComponent",{component:this,tagName:"CheckboxGroup",options:e,id:ie.name})}get original(){throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set original(e){throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get choices(){throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set choices(e){throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const V="src/components/Interpretation/InterpretationComponents/Slider.svelte";function Re(t,e,n){const a=t.slice();return a[6]=e[n],a}function Me(t){let e;const n={c:function(){e=C(t[5])},m:function(l,r){P(l,e,r)},p:function(l,r){r&32&&I(e,l[5])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:Me.name,type:"slot",source:"(12:1) <BlockTitle>",ctx:t}),n}function re(t){let e,n;const a={c:function(){e=k("div"),h(e,"style",n="background-color: "+y(t[6])),h(e,"class","svelte-cm5drz"),b(e,V,17,3,443)},m:function(r,c){P(r,e,c)},p:function(r,c){c&2&&n!==(n="background-color: "+y(r[6]))&&h(e,"style",n)},d:function(r){r&&S(e)}};return _("SvelteRegisterBlock",{block:a,id:re.name,type:"each",source:"(15:2) {#each interpretation as interpret_value}",ctx:t}),a}function ce(t){let e,n,a,l,r,c,u,s,o,i;n=new x({props:{$$slots:{default:[Me]},$$scope:{ctx:t}},$$inline:!0});let f=N(t[1]),m=[];for(let v=0;v<f.length;v+=1)m[v]=re(Re(t,f,v));const d={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("input"),r=j(),c=k("div");for(let p=0;p<m.length;p+=1)m[p].c();u=j(),s=k("div"),o=C(t[0]),h(l,"type","range"),l.disabled=!0,h(l,"min",t[2]),h(l,"max",t[3]),h(l,"step",t[4]),h(l,"class","svelte-cm5drz"),b(l,V,14,1,308),h(c,"class","range svelte-cm5drz"),b(c,V,15,1,376),h(s,"class","original svelte-cm5drz"),b(s,V,20,1,535),h(e,"class","input-slider svelte-cm5drz"),b(e,V,12,0,246)},l:function(p){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(p,g){P(p,e,g),G(n,e,null),w(e,a),w(e,l),w(e,r),w(e,c);for(let E=0;E<m.length;E+=1)m[E]&&m[E].m(c,null);w(e,u),w(e,s),w(s,o),i=!0},p:function(p,[g]){const E={};if(g&544&&(E.$$scope={dirty:g,ctx:p}),n.$set(E),(!i||g&4)&&h(l,"min",p[2]),(!i||g&8)&&h(l,"max",p[3]),(!i||g&16)&&h(l,"step",p[4]),g&2){f=N(p[1]);let R;for(R=0;R<f.length;R+=1){const L=Re(p,f,R);m[R]?m[R].p(L,g):(m[R]=re(L),m[R].c(),m[R].m(c,null))}for(;R<m.length;R+=1)m[R].d(1);m.length=f.length}(!i||g&1)&&I(o,p[0])},i:function(p){i||(B(n.$$.fragment,p),i=!0)},o:function(p){T(n.$$.fragment,p),i=!1},d:function(p){p&&S(e),D(n),H(m,p)}};return _("SvelteRegisterBlock",{block:d,id:ce.name,type:"component",source:"",ctx:t}),d}function st(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Slider",a,[]);let{original:r}=e,{interpretation:c}=e,{minimum:u}=e,{maximum:s}=e,{step:o}=e,{label:i=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("original"in e||t.$$.bound[t.$$.props.original])&&console.warn("<Slider> was created without expected prop 'original'"),c===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Slider> was created without expected prop 'interpretation'"),u===void 0&&!("minimum"in e||t.$$.bound[t.$$.props.minimum])&&console.warn("<Slider> was created without expected prop 'minimum'"),s===void 0&&!("maximum"in e||t.$$.bound[t.$$.props.maximum])&&console.warn("<Slider> was created without expected prop 'maximum'"),o===void 0&&!("step"in e||t.$$.bound[t.$$.props.step])&&console.warn("<Slider> was created without expected prop 'step'")});const f=["original","interpretation","minimum","maximum","step","label"];return Object.keys(e).forEach(m=>{!~f.indexOf(m)&&m.slice(0,2)!=="$$"&&m!=="slot"&&console.warn(`<Slider> was created with unknown prop '${m}'`)}),t.$$set=m=>{"original"in m&&n(0,r=m.original),"interpretation"in m&&n(1,c=m.interpretation),"minimum"in m&&n(2,u=m.minimum),"maximum"in m&&n(3,s=m.maximum),"step"in m&&n(4,o=m.step),"label"in m&&n(5,i=m.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,original:r,interpretation:c,minimum:u,maximum:s,step:o,label:i}),t.$inject_state=m=>{"original"in m&&n(0,r=m.original),"interpretation"in m&&n(1,c=m.interpretation),"minimum"in m&&n(2,u=m.minimum),"maximum"in m&&n(3,s=m.maximum),"step"in m&&n(4,o=m.step),"label"in m&&n(5,i=m.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c,u,s,o,i]}class lt extends A{constructor(e){super(e),z(this,e,st,ce,q,{original:0,interpretation:1,minimum:2,maximum:3,step:4,label:5}),_("SvelteRegisterComponent",{component:this,tagName:"Slider",options:e,id:ce.name})}get original(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set original(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get minimum(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set minimum(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get maximum(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set maximum(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get step(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set step(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const se="src/components/Interpretation/InterpretationComponents/Radio.svelte";function Ce(t,e,n){const a=t.slice();return a[4]=e[n],a[6]=n,a}function Fe(t){let e;const n={c:function(){e=C(t[3])},m:function(l,r){P(l,e,r)},p:function(l,r){r&8&&I(e,l[3])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:Fe.name,type:"slot",source:"(10:1) <BlockTitle>",ctx:t}),n}function le(t){let e,n,a,l,r=t[4]+"",c,u;const s={c:function(){e=k("button"),n=k("div"),l=j(),c=C(r),u=j(),h(n,"class","radio-circle svelte-99jija"),h(n,"style",a="background-color: "+y(t[1][t[6]])),b(n,se,14,3,369),h(e,"class","radio-item svelte-99jija"),K(e,"selected",t[0]===t[4]),b(e,se,13,2,301)},m:function(i,f){P(i,e,f),w(e,n),w(e,l),w(e,c),w(e,u)},p:function(i,f){f&2&&a!==(a="background-color: "+y(i[1][i[6]]))&&h(n,"style",a),f&4&&r!==(r=i[4]+"")&&I(c,r),f&5&&K(e,"selected",i[0]===i[4])},d:function(i){i&&S(e)}};return _("SvelteRegisterBlock",{block:s,id:le.name,type:"each",source:"(11:1) {#each choices as choice, i}",ctx:t}),s}function ae(t){let e,n,a,l;n=new x({props:{$$slots:{default:[Fe]},$$scope:{ctx:t}},$$inline:!0});let r=N(t[2]),c=[];for(let s=0;s<r.length;s+=1)c[s]=le(Ce(t,r,s));const u={c:function(){e=k("div"),O(n.$$.fragment),a=j();for(let o=0;o<c.length;o+=1)c[o].c();h(e,"class","input-radio svelte-99jija"),b(e,se,10,0,209)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,i){P(o,e,i),G(n,e,null),w(e,a);for(let f=0;f<c.length;f+=1)c[f]&&c[f].m(e,null);l=!0},p:function(o,[i]){const f={};if(i&136&&(f.$$scope={dirty:i,ctx:o}),n.$set(f),i&7){r=N(o[2]);let m;for(m=0;m<r.length;m+=1){const d=Ce(o,r,m);c[m]?c[m].p(d,i):(c[m]=le(d),c[m].c(),c[m].m(e,null))}for(;m<c.length;m+=1)c[m].d(1);c.length=r.length}},i:function(o){l||(B(n.$$.fragment,o),l=!0)},o:function(o){T(n.$$.fragment,o),l=!1},d:function(o){o&&S(e),D(n),H(c,o)}};return _("SvelteRegisterBlock",{block:u,id:ae.name,type:"component",source:"",ctx:t}),u}function at(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Radio",a,[]);let{original:r}=e,{interpretation:c}=e,{choices:u}=e,{label:s=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("original"in e||t.$$.bound[t.$$.props.original])&&console.warn("<Radio> was created without expected prop 'original'"),c===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Radio> was created without expected prop 'interpretation'"),u===void 0&&!("choices"in e||t.$$.bound[t.$$.props.choices])&&console.warn("<Radio> was created without expected prop 'choices'")});const o=["original","interpretation","choices","label"];return Object.keys(e).forEach(i=>{!~o.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<Radio> was created with unknown prop '${i}'`)}),t.$$set=i=>{"original"in i&&n(0,r=i.original),"interpretation"in i&&n(1,c=i.interpretation),"choices"in i&&n(2,u=i.choices),"label"in i&&n(3,s=i.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,original:r,interpretation:c,choices:u,label:s}),t.$inject_state=i=>{"original"in i&&n(0,r=i.original),"interpretation"in i&&n(1,c=i.interpretation),"choices"in i&&n(2,u=i.choices),"label"in i&&n(3,s=i.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c,u,s]}class ut extends A{constructor(e){super(e),z(this,e,at,ae,q,{original:0,interpretation:1,choices:2,label:3}),_("SvelteRegisterComponent",{component:this,tagName:"Radio",options:e,id:ae.name})}get original(){throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set original(e){throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get choices(){throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set choices(e){throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Q="src/components/Interpretation/InterpretationComponents/Image.svelte";function Ue(t){let e;const n={c:function(){e=C(t[1])},m:function(l,r){P(l,e,r)},p:function(l,r){r&2&&I(e,l[1])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:Ue.name,type:"slot",source:"(38:1) <BlockTitle>",ctx:t}),n}function ue(t){let e,n,a,l,r,c,u,s,o,i;n=new x({props:{$$slots:{default:[Ue]},$$scope:{ctx:t}},$$inline:!0});const f={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("div"),r=k("div"),c=k("canvas"),u=j(),s=k("img"),b(c,Q,67,3,1340),h(r,"class","interpretation svelte-174xtu6"),b(r,Q,66,2,1308),ye(s.src,o=t[0])||h(s,"src",o),h(s,"class","svelte-174xtu6"),b(s,Q,70,2,1437),h(l,"class","image-preview svelte-174xtu6"),b(l,Q,65,1,1278),h(e,"class","input-image"),b(e,Q,63,0,1217)},l:function(d){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(d,v){P(d,e,v),G(n,e,null),w(e,a),w(e,l),w(l,r),w(r,c),t[6](c),w(l,u),w(l,s),t[7](s),i=!0},p:function(d,[v]){const p={};v&514&&(p.$$scope={dirty:v,ctx:d}),n.$set(p),(!i||v&1&&!ye(s.src,o=d[0]))&&h(s,"src",o)},i:function(d){i||(B(n.$$.fragment,d),i=!0)},o:function(d){T(n.$$.fragment,d),i=!1},d:function(d){d&&S(e),D(n),t[6](null),t[7](null)}};return _("SvelteRegisterBlock",{block:f,id:ue.name,type:"component",source:"",ctx:t}),f}function mt(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Image",a,[]);let{original:r}=e,{interpretation:c}=e,{shape:u}=e,{label:s=""}=e,o,i;function f(p,g,E,R){var L=E/p[0].length,be=R/p.length,_e=0;p.forEach(function(Le){var ve=0;Le.forEach(function(Qe){g.fillStyle=y(Qe),g.fillRect(ve*L,_e*be,L,be),ve++}),_e++})}ke(()=>{let p=W(!0,i.width,i.height,i.naturalWidth,i.naturalHeight);u&&(p=W(!0,p.width,p.height,u[0],u[1]));let g=p.width,E=p.height;o.setAttribute("height",`${E}`),o.setAttribute("width",`${g}`),f(c,o.getContext("2d"),g,E)}),t.$$.on_mount.push(function(){r===void 0&&!("original"in e||t.$$.bound[t.$$.props.original])&&console.warn("<Image> was created without expected prop 'original'"),c===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Image> was created without expected prop 'interpretation'"),u===void 0&&!("shape"in e||t.$$.bound[t.$$.props.shape])&&console.warn("<Image> was created without expected prop 'shape'")});const m=["original","interpretation","shape","label"];Object.keys(e).forEach(p=>{!~m.indexOf(p)&&p.slice(0,2)!=="$$"&&p!=="slot"&&console.warn(`<Image> was created with unknown prop '${p}'`)});function d(p){Ee[p?"unshift":"push"](()=>{o=p,n(2,o)})}function v(p){Ee[p?"unshift":"push"](()=>{i=p,n(3,i)})}return t.$$set=p=>{"original"in p&&n(0,r=p.original),"interpretation"in p&&n(4,c=p.interpretation),"shape"in p&&n(5,u=p.shape),"label"in p&&n(1,s=p.label)},t.$capture_state=()=>({getSaliencyColor:y,getObjectFitSize:W,afterUpdate:ke,BlockTitle:x,original:r,interpretation:c,shape:u,label:s,saliency_layer:o,image:i,paintSaliency:f}),t.$inject_state=p=>{"original"in p&&n(0,r=p.original),"interpretation"in p&&n(4,c=p.interpretation),"shape"in p&&n(5,u=p.shape),"label"in p&&n(1,s=p.label),"saliency_layer"in p&&n(2,o=p.saliency_layer),"image"in p&&n(3,i=p.image)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,s,o,i,c,u,d,v]}class ht extends A{constructor(e){super(e),z(this,e,mt,ue,q,{original:0,interpretation:4,shape:5,label:1}),_("SvelteRegisterComponent",{component:this,tagName:"Image",options:e,id:ue.name})}get original(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set original(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get shape(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set shape(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const me="src/components/Interpretation/InterpretationComponents/Audio.svelte";function Ie(t,e,n){const a=t.slice();return a[2]=e[n],a}function He(t){let e;const n={c:function(){e=C(t[1])},m:function(l,r){P(l,e,r)},p:function(l,r){r&2&&I(e,l[1])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:He.name,type:"slot",source:"(8:1) <BlockTitle>",ctx:t}),n}function he(t){let e,n;const a={c:function(){e=k("div"),h(e,"class","item svelte-1lacsdh"),h(e,"style",n="background-color: "+y(t[2])),b(e,me,11,3,276)},m:function(r,c){P(r,e,c)},p:function(r,c){c&1&&n!==(n="background-color: "+y(r[2]))&&h(e,"style",n)},d:function(r){r&&S(e)}};return _("SvelteRegisterBlock",{block:a,id:he.name,type:"each",source:"(10:2) {#each interpretation as interpret_value}",ctx:t}),a}function fe(t){let e,n,a,l,r;n=new x({props:{$$slots:{default:[He]},$$scope:{ctx:t}},$$inline:!0});let c=N(t[0]),u=[];for(let o=0;o<c.length;o+=1)u[o]=he(Ie(t,c,o));const s={c:function(){e=k("div"),O(n.$$.fragment),a=j(),l=k("div");for(let i=0;i<u.length;i+=1)u[i].c();h(l,"class","range svelte-1lacsdh"),b(l,me,9,1,209),b(e,me,7,0,168)},l:function(i){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(i,f){P(i,e,f),G(n,e,null),w(e,a),w(e,l);for(let m=0;m<u.length;m+=1)u[m]&&u[m].m(l,null);r=!0},p:function(i,[f]){const m={};if(f&34&&(m.$$scope={dirty:f,ctx:i}),n.$set(m),f&1){c=N(i[0]);let d;for(d=0;d<c.length;d+=1){const v=Ie(i,c,d);u[d]?u[d].p(v,f):(u[d]=he(v),u[d].c(),u[d].m(l,null))}for(;d<u.length;d+=1)u[d].d(1);u.length=c.length}},i:function(i){r||(B(n.$$.fragment,i),r=!0)},o:function(i){T(n.$$.fragment,i),r=!1},d:function(i){i&&S(e),D(n),H(u,i)}};return _("SvelteRegisterBlock",{block:s,id:fe.name,type:"component",source:"",ctx:t}),s}function ft(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Audio",a,[]);let{interpretation:r}=e,{label:c=""}=e;t.$$.on_mount.push(function(){r===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Audio> was created without expected prop 'interpretation'")});const u=["interpretation","label"];return Object.keys(e).forEach(s=>{!~u.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<Audio> was created with unknown prop '${s}'`)}),t.$$set=s=>{"interpretation"in s&&n(0,r=s.interpretation),"label"in s&&n(1,c=s.label)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,interpretation:r,label:c}),t.$inject_state=s=>{"interpretation"in s&&n(0,r=s.interpretation),"label"in s&&n(1,c=s.label)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c]}class pt extends A{constructor(e){super(e),z(this,e,ft,fe,q,{interpretation:0,label:1}),_("SvelteRegisterComponent",{component:this,tagName:"Audio",options:e,id:fe.name})}get interpretation(){throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get label(){throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Je="src/components/Interpretation/InterpretationComponents/Textbox.svelte";function Be(t,e,n){const a=t.slice();return a[2]=e[n][0],a[3]=e[n][1],a}function Ke(t){let e;const n={c:function(){e=C(t[0])},m:function(l,r){P(l,e,r)},p:function(l,r){r&1&&I(e,l[0])},d:function(l){l&&S(e)}};return _("SvelteRegisterBlock",{block:n,id:Ke.name,type:"slot",source:"(8:1) <BlockTitle>",ctx:t}),n}function pe(t){let e,n=t[2]+"",a,l,r;const c={c:function(){e=k("span"),a=C(n),l=j(),h(e,"class","text-span svelte-47g92a"),h(e,"style",r="background-color: "+y(t[3])),b(e,Je,10,2,273)},m:function(s,o){P(s,e,o),w(e,a),w(e,l)},p:function(s,o){o&2&&n!==(n=s[2]+"")&&I(a,n),o&2&&r!==(r="background-color: "+y(s[3]))&&h(e,"style",r)},d:function(s){s&&S(e)}};return _("SvelteRegisterBlock",{block:c,id:pe.name,type:"each",source:"(9:1) {#each interpretation as [text, saliency]}",ctx:t}),c}function de(t){let e,n,a,l;n=new x({props:{$$slots:{default:[Ke]},$$scope:{ctx:t}},$$inline:!0});let r=N(t[1]),c=[];for(let s=0;s<r.length;s+=1)c[s]=pe(Be(t,r,s));const u={c:function(){e=k("div"),O(n.$$.fragment),a=j();for(let o=0;o<c.length;o+=1)c[o].c();h(e,"class","input-text svelte-47g92a"),b(e,Je,7,0,168)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,i){P(o,e,i),G(n,e,null),w(e,a);for(let f=0;f<c.length;f+=1)c[f]&&c[f].m(e,null);l=!0},p:function(o,[i]){const f={};if(i&65&&(f.$$scope={dirty:i,ctx:o}),n.$set(f),i&2){r=N(o[1]);let m;for(m=0;m<r.length;m+=1){const d=Be(o,r,m);c[m]?c[m].p(d,i):(c[m]=pe(d),c[m].c(),c[m].m(e,null))}for(;m<c.length;m+=1)c[m].d(1);c.length=r.length}},i:function(o){l||(B(n.$$.fragment,o),l=!0)},o:function(o){T(n.$$.fragment,o),l=!1},d:function(o){o&&S(e),D(n),H(c,o)}};return _("SvelteRegisterBlock",{block:u,id:de.name,type:"component",source:"",ctx:t}),u}function dt(t,e,n){let{$$slots:a={},$$scope:l}=e;M("Textbox",a,[]);let{label:r=""}=e,{interpretation:c}=e;t.$$.on_mount.push(function(){c===void 0&&!("interpretation"in e||t.$$.bound[t.$$.props.interpretation])&&console.warn("<Textbox> was created without expected prop 'interpretation'")});const u=["label","interpretation"];return Object.keys(e).forEach(s=>{!~u.indexOf(s)&&s.slice(0,2)!=="$$"&&s!=="slot"&&console.warn(`<Textbox> was created with unknown prop '${s}'`)}),t.$$set=s=>{"label"in s&&n(0,r=s.label),"interpretation"in s&&n(1,c=s.interpretation)},t.$capture_state=()=>({getSaliencyColor:y,BlockTitle:x,label:r,interpretation:c}),t.$inject_state=s=>{"label"in s&&n(0,r=s.label),"interpretation"in s&&n(1,c=s.interpretation)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),[r,c]}class wt extends A{constructor(e){super(e),z(this,e,dt,de,q,{label:0,interpretation:1}),_("SvelteRegisterComponent",{component:this,tagName:"Textbox",options:e,id:de.name})}get label(){throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set label(e){throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get interpretation(){throw new Error("<Textbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set interpretation(e){throw new Error("<Textbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Ne={audio:pt,dropdown:nt,checkbox:it,checkboxgroup:ct,number:et,slider:lt,radio:ut,image:ht,textbox:wt};function we(t){let e,n,a;const l=[t[0],{original:t[1].original},{interpretation:t[1].interpretation}];var r=t[2];function c(s){let o={};for(let i=0;i<l.length;i+=1)o=Ve(o,l[i]);return{props:o,$$inline:!0}}r&&(e=Pe(r,c()));const u={c:function(){e&&O(e.$$.fragment),n=Te()},m:function(o,i){e&&G(e,o,i),P(o,n,i),a=!0},p:function(o,i){const f=i&3?We(l,[i&1&&Xe(o[0]),i&2&&{original:o[1].original},i&2&&{interpretation:o[1].interpretation}]):{};if(i&4&&r!==(r=o[2])){if(e){Oe();const m=e;T(m.$$.fragment,1,0,()=>{D(m,1)}),Ge()}r?(e=Pe(r,c()),O(e.$$.fragment),B(e.$$.fragment,1),G(e,n.parentNode,n)):e=null}else r&&e.$set(f)},i:function(o){a||(e&&B(e.$$.fragment,o),a=!0)},o:function(o){e&&T(e.$$.fragment,o),a=!1},d:function(o){o&&S(n),e&&D(e,o)}};return _("SvelteRegisterBlock",{block:u,id:we.name,type:"if",source:"(8:0) {#if value}",ctx:t}),u}function ge(t){let e,n,a=t[1]&&we(t);const l={c:function(){a&&a.c(),e=Te()},l:function(c){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,u){a&&a.m(c,u),P(c,e,u),n=!0},p:function(c,[u]){c[1]?a?(a.p(c,u),u&2&&B(a,1)):(a=we(c),a.c(),B(a,1),a.m(e.parentNode,e)):a&&(Oe(),T(a,1,1,()=>{a=null}),Ge())},i:function(c){n||(B(a),n=!0)},o:function(c){T(a),n=!1},d:function(c){c&&S(e),a&&a.d(c)}};return _("SvelteRegisterBlock",{block:l,id:ge.name,type:"component",source:"",ctx:t}),l}function gt(t,e,n){let a,{$$slots:l={},$$scope:r}=e;M("Interpretation",l,[]);let{component:c}=e,{component_props:u}=e,{value:s}=e;t.$$.on_mount.push(function(){c===void 0&&!("component"in e||t.$$.bound[t.$$.props.component])&&console.warn("<Interpretation> was created without expected prop 'component'"),u===void 0&&!("component_props"in e||t.$$.bound[t.$$.props.component_props])&&console.warn("<Interpretation> was created without expected prop 'component_props'"),s===void 0&&!("value"in e||t.$$.bound[t.$$.props.value])&&console.warn("<Interpretation> was created without expected prop 'value'")});const o=["component","component_props","value"];return Object.keys(e).forEach(i=>{!~o.indexOf(i)&&i.slice(0,2)!=="$$"&&i!=="slot"&&console.warn(`<Interpretation> was created with unknown prop '${i}'`)}),t.$$set=i=>{"component"in i&&n(3,c=i.component),"component_props"in i&&n(0,u=i.component_props),"value"in i&&n(1,s=i.value)},t.$capture_state=()=>({component_map:Ne,component:c,component_props:u,value:s,_component:a}),t.$inject_state=i=>{"component"in i&&n(3,c=i.component),"component_props"in i&&n(0,u=i.component_props),"value"in i&&n(1,s=i.value),"_component"in i&&n(2,a=i._component)},e&&"$$inject"in e&&t.$inject_state(e.$$inject),t.$$.update=()=>{t.$$.dirty&8&&n(2,a=Ne[c])},[u,s,a,c]}class bt extends A{constructor(e){super(e),z(this,e,gt,ge,q,{component:3,component_props:0,value:1}),_("SvelteRegisterComponent",{component:this,tagName:"Interpretation",options:e,id:ge.name})}get component(){throw new Error("<Interpretation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set component(e){throw new Error("<Interpretation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get component_props(){throw new Error("<Interpretation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set component_props(e){throw new Error("<Interpretation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get value(){throw new Error("<Interpretation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set value(e){throw new Error("<Interpretation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}const Pt=bt;export{Pt as default};
//# sourceMappingURL=index-df5967b9.js.map
