import{SvelteComponentDev as y,init as T,safe_not_equal as j,dispatch_dev as w,create_slot as E,validate_slots as P,element as S,space as R,empty as I,attr_dev as g,toggle_class as _,add_location as C,insert_dev as d,update_slot_base as N,get_all_dirty_from_scope as O,get_slot_changes as q,transition_in as m,group_outros as D,transition_out as p,check_outros as U,detach_dev as h,create_component as z,mount_component as A,destroy_component as F,text as G,set_data_dev as H}from"../../../node/dev/svelte-internal.js";import"./index-09ad131b.js";import{I as v}from"./Info-94616ea2.js";import"./Button-70427016.js";const J="Users/peterallen/Projects/gradio/js/atoms/src/BlockTitle.svelte";function b(i){let e,r;e=new v({props:{$$slots:{default:[B]},$$scope:{ctx:i}},$$inline:!0});const a={c:function(){z(e.$$.fragment)},m:function(s,l){A(e,s,l),r=!0},p:function(s,l){const n={};l&10&&(n.$$scope={dirty:l,ctx:s}),e.$set(n)},i:function(s){r||(m(e.$$.fragment,s),r=!0)},o:function(s){p(e.$$.fragment,s),r=!1},d:function(s){F(e,s)}};return w("SvelteRegisterBlock",{block:a,id:b.name,type:"if",source:"(14:0) {#if info}",ctx:i}),a}function B(i){let e;const r={c:function(){e=G(i[1])},m:function(t,s){d(t,e,s)},p:function(t,s){s&2&&H(e,t[1])},d:function(t){t&&h(e)}};return w("SvelteRegisterBlock",{block:r,id:B.name,type:"slot",source:"(15:1) <Info>",ctx:i}),r}function k(i){let e,r,a,t;const s=i[2].default,l=E(s,i,i[3],null);let n=i[1]&&b(i);const c={c:function(){e=S("span"),l&&l.c(),r=R(),n&&n.c(),a=I(),g(e,"data-testid","block-info"),g(e,"class","svelte-22c38v"),_(e,"sr-only",!i[0]),_(e,"hide",!i[0]),_(e,"has-info",i[1]!=null),C(e,J,6,0,137)},l:function(o){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(o,f){d(o,e,f),l&&l.m(e,null),d(o,r,f),n&&n.m(o,f),d(o,a,f),t=!0},p:function(o,[f]){l&&l.p&&(!t||f&8)&&N(l,s,o,o[3],t?q(s,o[3],f,null):O(o[3]),null),(!t||f&1)&&_(e,"sr-only",!o[0]),(!t||f&1)&&_(e,"hide",!o[0]),(!t||f&2)&&_(e,"has-info",o[1]!=null),o[1]?n?(n.p(o,f),f&2&&m(n,1)):(n=b(o),n.c(),m(n,1),n.m(a.parentNode,a)):n&&(D(),p(n,1,1,()=>{n=null}),U())},i:function(o){t||(m(l,o),m(n),t=!0)},o:function(o){p(l,o),p(n),t=!1},d:function(o){o&&(h(e),h(r),h(a)),l&&l.d(o),n&&n.d(o)}};return w("SvelteRegisterBlock",{block:c,id:k.name,type:"component",source:"",ctx:i}),c}function K(i,e,r){let{$$slots:a={},$$scope:t}=e;P("BlockTitle",a,["default"]);let{show_label:s=!0}=e,{info:l=void 0}=e;const n=["show_label","info"];return Object.keys(e).forEach(c=>{!~n.indexOf(c)&&c.slice(0,2)!=="$$"&&c!=="slot"&&console.warn(`<BlockTitle> was created with unknown prop '${c}'`)}),i.$$set=c=>{"show_label"in c&&r(0,s=c.show_label),"info"in c&&r(1,l=c.info),"$$scope"in c&&r(3,t=c.$$scope)},i.$capture_state=()=>({Info:v,show_label:s,info:l}),i.$inject_state=c=>{"show_label"in c&&r(0,s=c.show_label),"info"in c&&r(1,l=c.info)},e&&"$$inject"in e&&i.$inject_state(e.$$inject),[s,l,a,t]}class W extends y{constructor(e){super(e),T(this,e,K,k,j,{show_label:0,info:1}),w("SvelteRegisterComponent",{component:this,tagName:"BlockTitle",options:e,id:k.name})}get show_label(){throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set show_label(e){throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get info(){throw new Error("<BlockTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set info(e){throw new Error("<BlockTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}}export{W as B};
//# sourceMappingURL=BlockTitle-ed6bd46f.js.map
